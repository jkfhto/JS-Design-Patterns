# JS-Design-Patterns
Design Patterns applied to Javascript code

# 设计原则 SOLID

**Single-单一职责原则<br>**
定义：不要存在多余一个导致类变更的原因<br>
举例：class A负责两个职责，职责1，职责2，一旦需求变更，职责1相关功能需要改变，修改class A可能会导致原本运行正常的职责2出现问题。<br>
解决方法：一个类/方法/一个程序只负责一项职责，如果功能复杂就进行拆分，每个部分保持独立<br>
优点：降低类的复杂度，提高可读性，提高系统可维护性，降低变更引起的风险。<br>

**Open-开放封闭原则<br>**
定义：一个类/模块/函数应该对扩展开放，对修改封闭<br>
举例：增加新需求时，扩展新代码，而非修改已有代码<br>
解决方法：用抽象构建框架，面向抽象编程，用实现扩展细节<br>
优点：提高系统的可维护性，可复用性以及稳定性<br>

**L-里氏置换原则<br>**
子类能覆盖父类<br>
父类能出现的地方子类就能出现<br>
JS中使用较少(弱类型&继承使用较少<br>


**Interface-接口独立原则<br>**
定义：用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口<br>
js中没有接口（typescript）,使用较少<br>
优点：符合高内聚低耦合的设计思想，从而使得类具有很好的可读性，可扩展性和可维护性<br>

**Dependence-依赖倒置原则<br>**
定义：高层模块不应该依赖底层模块，两者都应该依赖其抽象<br>
面向接口编程，依赖于抽象而不依赖于具体，使用方只关注接口而不关注具体类的实现，js中使用较少（没有接口&弱类型）<br>
优点：降低类之间的耦合性，提高代码可读性和可维护性，提高系统稳定性，降低变更引起的风险。<br>

# 设计模式
- **简单工厂:**<br>
定义：由一个工厂对象决定创建出哪一个类的实例<br>
类型：创建型，但是不属于GOF23种设计模式<br>
适用场景：1：工厂类负责创建的对象比较少；&nbsp;&nbsp;&nbsp;&nbsp;2：客户端（应用层）只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心<br>
优点：只需要传入一个正确的参数，就可以获取你所需的对象，而无需知道具体具体的创建细节<br>
缺点：工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背开放封闭原则<br>
